from flask import Flask, g, url_for, request, render_template, make_response, redirect, send_from_directory, send_file, session, render_template_string, flash
from flask_login import LoginManager, login_user, UserMixin, current_user
from flask_simpleldap import LDAP
from bson.objectid import ObjectId
import subprocess
import json
import hashlib
from ole_parser import *
import os
from werkzeug import secure_filename
from werkzeug.wsgi import LimitedStream
from cuckoo import Cuckoo
import json
import base64
from peewee import *
from model import *

'''

This is a middleware object to handle wsgi file upload as flask dev server will term connection

'''
class StreamConsumingMiddleware(object):

    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        stream = LimitedStream(environ['wsgi.input'],
                               int(environ['CONTENT_LENGTH'] or 0))
        environ['wsgi.input'] = stream
        app_iter = self.app(environ, start_response)
        try:
            stream.exhaust()
            for event in app_iter:
                yield event
        finally:
            if hasattr(app_iter, 'close'):
                app_iter.close()


#Set up flask app object, upload folder, and configure wsgi workaround
app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = '/tmp'
app.wsgi_app = StreamConsumingMiddleware(app.wsgi_app)

#Configure CardinalHealth LDAP details and credentials
app.config['SECRET_KEY'] = ''
app.config['LDAP_HOST'] = ''             # Hostname of your LDAP Server
app.config['LDAP_BASE_DN'] = ''       # Base DN of your directory
app.config['LDAP_USERNAME'] = ''                  # The Username to bind to LDAP with
app.config['LDAP_PASSWORD'] = ''            # The Password to bind to LDAP with


#initialize LDAP object
ldap = LDAP(app)

# Create a dictionary to store the users in when they authenticate
users = {}


#Global variables to hold the submitted email metadata and attachments
email_meta = {}
attachments = {}

# This hook ensures that a connection is opened to handle any queries
# generated by the request.
@app.before_request
def _db_connect():
    db.connect()

# This hook ensures that the connection is closed when we've finished
# processing the request.
@app.teardown_request
def _db_close(exc):
    if not db.is_closed():
        db.close()

'''

    Given a filename this method will grab the attachment binary data from global dictionary to submit to Cuckoo

'''
@ldap.basic_auth_required
def send_file_to_cuckoo(fileName):

    cuckoo = Cuckoo("https://cuckoo-ip-here", "user", "password", verify=False)
    result = ''
    data = b''
    if attachment['name'] == fileName:
        data = attachment['data']
        result = cuckoo.submit_file(fileName,data)

    print(result)
    return result


'''
    This route functions as a RESTful exposure to update the email object from any of the modified fields on the stix editable layout. 
    Accepting POST requests with the new values, this function will update that field in the email_meta dictionary.
'''
@app.route('/parser/update', methods=['POST'])
@ldap.basic_auth_required
def update_stix_object():

    old = request.form['pk']
    new = request.form['value']
    column = request.form['name']
    result = None

    if column == 'tlp':
        if new == '1':
            email_meta[column] = "GREEN"
        elif new == '2':
            email_meta[column] = "AMBER"
        elif new == '3':
            email_meta[column] = "RED"
    else:
        email_meta[column] = new
    

    return '',200

'''
    This route functions as a RESTful exposure for file submission to Cuckoo, accepts POST requests indicating file name to submit. 
'''
@app.route('/cuckoo', methods=['POST'])
@ldap.basic_auth_required
def send_to_cuckoo():
    if request.method == 'POST':
        r = send_file_to_cuckoo(request.form['name'])
        if r != -1:
            return json.dumps({'id':r[0]})
        else:
            return '',500

'''
    This route functions as a RESTful exposure to build our STIX structure using the defined email attributes.
    This generates XML which is sent as a content-disposition to have the client browser start a download. 
'''
@app.route('/stix', methods=['POST'])
@ldap.basic_auth_required
def generate_stix():

    if request.method == 'POST':
        stix = email_observables_to_stix(email_meta,attachments)
        print(stix)
        if stix:
            response = make_response(stix)
            response.headers['Content-type'] = 'text/xml'
            response.headers["Content-Disposition"] = "attachment; filename='%s'.xml" % (email_meta['subject'])
            return response
        else:
            return '',500

'''
    This route functions as a RESTful exposure utilzied by DataTables clientside to populate table rows via AJAX. 
    A POST request provides the search query which is passed to our Model to pull out related emails. This uses full text search capabiliites of PostgreSQL
'''
@app.route('/fetch', methods=['POST'])
@ldap.basic_auth_required
def fetch():

    if request.method == 'POST':
        query = request.form['search']
        results_dict = {}
        email_results = email_search(query)
        row_list = list()
        for email in email_results:
            row = (email.raw_header,email.raw_body,email.attachments,email.email_hash)
            print(len(row))
            row_list.append(row)

        #We need to wrap our rows as the value for the key 'aaData', dataTables is expecting this format. 
        results_dict['aaData'] = row_list
        #JSONify data and return it
        json_list = json.dumps(results_dict)
        return json_list

'''
    This route functions as a RESTful exposure to download full .msg samples that are stored in PostgreSQL database.
    MD5 hash is utilized for file queries, a GET request w/ parameter hash will attempt to fetch the file and return a content disposition response.
'''
@app.route('/download', methods=['GET'])
@ldap.basic_auth_required
def download():

    if request.method == 'GET' and request.args.get('hash'):
        try:
            email_hash = request.args.get('hash')
            email = Email.get(Email.email_hash == email_hash)
            data = email.email_raw
            response = make_response(bytearray(data))
            response.headers['Content-type'] = 'application/vnd.ms-outlook'
            response.headers["Content-Disposition"] = "attachment; filename=%s.msg" % (email_hash)
            return response
        except:
            #return empty response
            return ('',204)
    else:
        return '',404

'''
    This route functions as a RESTful exposure to display the search result page, which is where our dataTable resides. A GET request will render
    the search template with no passed query data. A POST will render the page with supplied query parameter. This will be provided via search in the navbar. 
'''        
@app.route('/search', methods=['GET','POST'])
@ldap.basic_auth_required
def search():

    if request.method == 'GET':
        return render_template('search.html')
    elif request.method == 'POST':
        query = request.form['search']
        return render_template('search.html',data=query)


'''
This route acts a restful exposure for the email parsing workflow. On a GET request, the email .msg upload form is rendered.
On a POST request the submitted file is obtained and read, it is temporarily stored in /tmp and is sent to ole_parser for metadata extraction
and file attachment discovery. The email data and attachments are both returned and passed to the parser update template so the fields may be edited/redacted.
'''
@app.route('/parser', methods=['GET','POST'])
@app.route('/',methods=['GET','POST'])
@ldap.basic_auth_required
def parser():
    if request.method == 'GET':
        return render_template('upload.html')
    elif request.method == 'POST':
        file = request.files['file']
        file_data = file.read()
        m = hashlib.md5()
        m.update(file_data)
        email_hash = m.hexdigest()

        attachment_files = ''
        if file:
            filename = secure_filename(file.filename)
            file.save(os.path.join(app.config['UPLOAD_FOLDER'],filename))
            global email_meta;
            global attachments;
            email_meta,attachments = email_to_stix(file)
            for k in attachments:
                attachment_files += '%s;' % (str(k['name']))
        
        try:
            Email.get(Email.email_hash == email_hash)
        except DoesNotExist:
            try:
                email_db_obj = Email(raw_header=email_meta['raw_header'],raw_body=email_meta['raw_body'],attachments=attachment_files,email_hash=email_hash,email_raw=file_data)
                email_db_obj.save()
            except:
                flash("Failed to parse email, please check it was .msg format and not corrupt.")
                return redirect('/parser')

        return render_template('parser.html',data={'email':email_meta,'attach':attachments})

    return '',500


#Start the web server       
if __name__ == '__main__':
    app.run(
        host="0.0.0.0",
        port=5000,
        debug=True
)
